// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.6.1
//   protoc               v3.19.1
// source: emergency_ward_services.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { type CallContext, type CallOptions } from "nice-grpc-common";
import { Empty } from "./google/protobuf/empty";
import { Timestamp } from "./google/protobuf/timestamp";
import { SeverityCode } from "./medical_event";
import { Doctor, Patient } from "./user";
import { Ward } from "./ward";

export const protobufPackage = "com.git_commit_therapy.proto.emergency";

export interface AddPatientRequest {
  /** Patient Information */
  patient: Patient | undefined;
  severityCode: SeverityCode;
  /** Medical report written by nurse */
  medicalReport: string;
  examType: string;
  /** Nurse reference */
  doctor: Doctor | undefined;
}

export interface AddPatientResponse {
  /** Patient Information */
  patient: Patient | undefined;
  /** Emergency-ward id */
  emergencyPatientId: string;
  /** MedicalEvent id */
  medicalEventId: number;
}

export interface TransferPatientRequest {
  /** Patient Information */
  patient: Patient | undefined;
  /** Ward */
  ward: Ward | undefined;
}

export interface RemovePatientRequest {
  /** Patient Information */
  patient: Patient | undefined;
  /** MedicalEvent id */
  medicalEventId: number;
  dischargeLetter: string;
}

export interface CallPatientRequest {
  patient: Patient | undefined;
  ambulatory: string;
}

export interface QueueStatusResponse {
  queueStatus: { [key: string]: number };
}

export interface QueueStatusResponse_QueueStatusEntry {
  key: string;
  value: number;
}

export interface LastPatientsCalledResponse {
  patientsCalled: EmergencyWardPatient[];
}

export interface EmergencyWardPatient {
  callTime: Date | undefined;
  patientCode: string;
  severityCode: SeverityCode;
  ambulatory: string;
}

function createBaseAddPatientRequest(): AddPatientRequest {
  return {
    patient: undefined,
    severityCode: 0,
    medicalReport: "",
    examType: "",
    doctor: undefined,
  };
}

export const AddPatientRequest: MessageFns<AddPatientRequest> = {
  encode(
    message: AddPatientRequest,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.patient !== undefined) {
      Patient.encode(message.patient, writer.uint32(10).fork()).join();
    }
    if (message.severityCode !== 0) {
      writer.uint32(16).int32(message.severityCode);
    }
    if (message.medicalReport !== "") {
      writer.uint32(26).string(message.medicalReport);
    }
    if (message.examType !== "") {
      writer.uint32(34).string(message.examType);
    }
    if (message.doctor !== undefined) {
      Doctor.encode(message.doctor, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AddPatientRequest {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAddPatientRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.patient = Patient.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.severityCode = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.medicalReport = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.examType = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.doctor = Doctor.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<AddPatientRequest>): AddPatientRequest {
    return AddPatientRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AddPatientRequest>): AddPatientRequest {
    const message = createBaseAddPatientRequest();
    message.patient =
      object.patient !== undefined && object.patient !== null
        ? Patient.fromPartial(object.patient)
        : undefined;
    message.severityCode = object.severityCode ?? 0;
    message.medicalReport = object.medicalReport ?? "";
    message.examType = object.examType ?? "";
    message.doctor =
      object.doctor !== undefined && object.doctor !== null
        ? Doctor.fromPartial(object.doctor)
        : undefined;
    return message;
  },
};

function createBaseAddPatientResponse(): AddPatientResponse {
  return { patient: undefined, emergencyPatientId: "", medicalEventId: 0 };
}

export const AddPatientResponse: MessageFns<AddPatientResponse> = {
  encode(
    message: AddPatientResponse,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.patient !== undefined) {
      Patient.encode(message.patient, writer.uint32(10).fork()).join();
    }
    if (message.emergencyPatientId !== "") {
      writer.uint32(18).string(message.emergencyPatientId);
    }
    if (message.medicalEventId !== 0) {
      writer.uint32(24).int32(message.medicalEventId);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): AddPatientResponse {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAddPatientResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.patient = Patient.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.emergencyPatientId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.medicalEventId = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<AddPatientResponse>): AddPatientResponse {
    return AddPatientResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AddPatientResponse>): AddPatientResponse {
    const message = createBaseAddPatientResponse();
    message.patient =
      object.patient !== undefined && object.patient !== null
        ? Patient.fromPartial(object.patient)
        : undefined;
    message.emergencyPatientId = object.emergencyPatientId ?? "";
    message.medicalEventId = object.medicalEventId ?? 0;
    return message;
  },
};

function createBaseTransferPatientRequest(): TransferPatientRequest {
  return { patient: undefined, ward: undefined };
}

export const TransferPatientRequest: MessageFns<TransferPatientRequest> = {
  encode(
    message: TransferPatientRequest,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.patient !== undefined) {
      Patient.encode(message.patient, writer.uint32(10).fork()).join();
    }
    if (message.ward !== undefined) {
      Ward.encode(message.ward, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): TransferPatientRequest {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTransferPatientRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.patient = Patient.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.ward = Ward.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<TransferPatientRequest>): TransferPatientRequest {
    return TransferPatientRequest.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<TransferPatientRequest>,
  ): TransferPatientRequest {
    const message = createBaseTransferPatientRequest();
    message.patient =
      object.patient !== undefined && object.patient !== null
        ? Patient.fromPartial(object.patient)
        : undefined;
    message.ward =
      object.ward !== undefined && object.ward !== null
        ? Ward.fromPartial(object.ward)
        : undefined;
    return message;
  },
};

function createBaseRemovePatientRequest(): RemovePatientRequest {
  return { patient: undefined, medicalEventId: 0, dischargeLetter: "" };
}

export const RemovePatientRequest: MessageFns<RemovePatientRequest> = {
  encode(
    message: RemovePatientRequest,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.patient !== undefined) {
      Patient.encode(message.patient, writer.uint32(10).fork()).join();
    }
    if (message.medicalEventId !== 0) {
      writer.uint32(16).int32(message.medicalEventId);
    }
    if (message.dischargeLetter !== "") {
      writer.uint32(26).string(message.dischargeLetter);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): RemovePatientRequest {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRemovePatientRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.patient = Patient.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.medicalEventId = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.dischargeLetter = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<RemovePatientRequest>): RemovePatientRequest {
    return RemovePatientRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RemovePatientRequest>): RemovePatientRequest {
    const message = createBaseRemovePatientRequest();
    message.patient =
      object.patient !== undefined && object.patient !== null
        ? Patient.fromPartial(object.patient)
        : undefined;
    message.medicalEventId = object.medicalEventId ?? 0;
    message.dischargeLetter = object.dischargeLetter ?? "";
    return message;
  },
};

function createBaseCallPatientRequest(): CallPatientRequest {
  return { patient: undefined, ambulatory: "" };
}

export const CallPatientRequest: MessageFns<CallPatientRequest> = {
  encode(
    message: CallPatientRequest,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.patient !== undefined) {
      Patient.encode(message.patient, writer.uint32(10).fork()).join();
    }
    if (message.ambulatory !== "") {
      writer.uint32(18).string(message.ambulatory);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): CallPatientRequest {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCallPatientRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.patient = Patient.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.ambulatory = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<CallPatientRequest>): CallPatientRequest {
    return CallPatientRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CallPatientRequest>): CallPatientRequest {
    const message = createBaseCallPatientRequest();
    message.patient =
      object.patient !== undefined && object.patient !== null
        ? Patient.fromPartial(object.patient)
        : undefined;
    message.ambulatory = object.ambulatory ?? "";
    return message;
  },
};

function createBaseQueueStatusResponse(): QueueStatusResponse {
  return { queueStatus: {} };
}

export const QueueStatusResponse: MessageFns<QueueStatusResponse> = {
  encode(
    message: QueueStatusResponse,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    Object.entries(message.queueStatus).forEach(([key, value]) => {
      QueueStatusResponse_QueueStatusEntry.encode(
        { key: key as any, value },
        writer.uint32(10).fork(),
      ).join();
    });
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): QueueStatusResponse {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueueStatusResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          const entry1 = QueueStatusResponse_QueueStatusEntry.decode(
            reader,
            reader.uint32(),
          );
          if (entry1.value !== undefined) {
            message.queueStatus[entry1.key] = entry1.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<QueueStatusResponse>): QueueStatusResponse {
    return QueueStatusResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<QueueStatusResponse>): QueueStatusResponse {
    const message = createBaseQueueStatusResponse();
    message.queueStatus = Object.entries(object.queueStatus ?? {}).reduce<{
      [key: string]: number;
    }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.Number(value);
      }
      return acc;
    }, {});
    return message;
  },
};

function createBaseQueueStatusResponse_QueueStatusEntry(): QueueStatusResponse_QueueStatusEntry {
  return { key: "", value: 0 };
}

export const QueueStatusResponse_QueueStatusEntry: MessageFns<QueueStatusResponse_QueueStatusEntry> =
  {
    encode(
      message: QueueStatusResponse_QueueStatusEntry,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      if (message.key !== "") {
        writer.uint32(10).string(message.key);
      }
      if (message.value !== 0) {
        writer.uint32(16).int32(message.value);
      }
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number,
    ): QueueStatusResponse_QueueStatusEntry {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseQueueStatusResponse_QueueStatusEntry();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1: {
            if (tag !== 10) {
              break;
            }

            message.key = reader.string();
            continue;
          }
          case 2: {
            if (tag !== 16) {
              break;
            }

            message.value = reader.int32();
            continue;
          }
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    create(
      base?: DeepPartial<QueueStatusResponse_QueueStatusEntry>,
    ): QueueStatusResponse_QueueStatusEntry {
      return QueueStatusResponse_QueueStatusEntry.fromPartial(base ?? {});
    },
    fromPartial(
      object: DeepPartial<QueueStatusResponse_QueueStatusEntry>,
    ): QueueStatusResponse_QueueStatusEntry {
      const message = createBaseQueueStatusResponse_QueueStatusEntry();
      message.key = object.key ?? "";
      message.value = object.value ?? 0;
      return message;
    },
  };

function createBaseLastPatientsCalledResponse(): LastPatientsCalledResponse {
  return { patientsCalled: [] };
}

export const LastPatientsCalledResponse: MessageFns<LastPatientsCalledResponse> =
  {
    encode(
      message: LastPatientsCalledResponse,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      for (const v of message.patientsCalled) {
        EmergencyWardPatient.encode(v!, writer.uint32(10).fork()).join();
      }
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number,
    ): LastPatientsCalledResponse {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseLastPatientsCalledResponse();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1: {
            if (tag !== 10) {
              break;
            }

            message.patientsCalled.push(
              EmergencyWardPatient.decode(reader, reader.uint32()),
            );
            continue;
          }
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    create(
      base?: DeepPartial<LastPatientsCalledResponse>,
    ): LastPatientsCalledResponse {
      return LastPatientsCalledResponse.fromPartial(base ?? {});
    },
    fromPartial(
      object: DeepPartial<LastPatientsCalledResponse>,
    ): LastPatientsCalledResponse {
      const message = createBaseLastPatientsCalledResponse();
      message.patientsCalled =
        object.patientsCalled?.map((e) =>
          EmergencyWardPatient.fromPartial(e),
        ) || [];
      return message;
    },
  };

function createBaseEmergencyWardPatient(): EmergencyWardPatient {
  return {
    callTime: undefined,
    patientCode: "",
    severityCode: 0,
    ambulatory: "",
  };
}

export const EmergencyWardPatient: MessageFns<EmergencyWardPatient> = {
  encode(
    message: EmergencyWardPatient,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.callTime !== undefined) {
      Timestamp.encode(
        toTimestamp(message.callTime),
        writer.uint32(10).fork(),
      ).join();
    }
    if (message.patientCode !== "") {
      writer.uint32(18).string(message.patientCode);
    }
    if (message.severityCode !== 0) {
      writer.uint32(24).int32(message.severityCode);
    }
    if (message.ambulatory !== "") {
      writer.uint32(34).string(message.ambulatory);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): EmergencyWardPatient {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEmergencyWardPatient();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.callTime = fromTimestamp(
            Timestamp.decode(reader, reader.uint32()),
          );
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.patientCode = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.severityCode = reader.int32() as any;
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.ambulatory = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<EmergencyWardPatient>): EmergencyWardPatient {
    return EmergencyWardPatient.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<EmergencyWardPatient>): EmergencyWardPatient {
    const message = createBaseEmergencyWardPatient();
    message.callTime = object.callTime ?? undefined;
    message.patientCode = object.patientCode ?? "";
    message.severityCode = object.severityCode ?? 0;
    message.ambulatory = object.ambulatory ?? "";
    return message;
  },
};

export type EmergencyWardServicesDefinition =
  typeof EmergencyWardServicesDefinition;
export const EmergencyWardServicesDefinition = {
  name: "EmergencyWardServices",
  fullName: "com.git_commit_therapy.proto.emergency.EmergencyWardServices",
  methods: {
    /** Method for adding a patient to the emergency ward. Returns a code to identify the patient in the waiting queue */
    addPatient: {
      name: "AddPatient",
      requestType: AddPatientRequest,
      requestStream: false,
      responseType: AddPatientResponse,
      responseStream: false,
      options: {},
    },
    /** Transfers a patient from the emergency ward to a specific ward. */
    transferPatient: {
      name: "TransferPatient",
      requestType: TransferPatientRequest,
      requestStream: false,
      responseType: Empty,
      responseStream: false,
      options: {},
    },
    /** Removes a patient from the emergency ward. */
    removePatient: {
      name: "RemovePatient",
      requestType: RemovePatientRequest,
      requestStream: false,
      responseType: Empty,
      responseStream: false,
      options: {},
    },
    /** Notifies a patient that is called for a visit */
    callPatientForVisit: {
      name: "CallPatientForVisit",
      requestType: CallPatientRequest,
      requestStream: false,
      responseType: Empty,
      responseStream: false,
      options: {},
    },
  },
} as const;

export interface EmergencyWardServicesServiceImplementation<
  CallContextExt = {},
> {
  /** Method for adding a patient to the emergency ward. Returns a code to identify the patient in the waiting queue */
  addPatient(
    request: AddPatientRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<AddPatientResponse>>;
  /** Transfers a patient from the emergency ward to a specific ward. */
  transferPatient(
    request: TransferPatientRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Empty>>;
  /** Removes a patient from the emergency ward. */
  removePatient(
    request: RemovePatientRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Empty>>;
  /** Notifies a patient that is called for a visit */
  callPatientForVisit(
    request: CallPatientRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Empty>>;
}

export interface EmergencyWardServicesClient<CallOptionsExt = {}> {
  /** Method for adding a patient to the emergency ward. Returns a code to identify the patient in the waiting queue */
  addPatient(
    request: DeepPartial<AddPatientRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<AddPatientResponse>;
  /** Transfers a patient from the emergency ward to a specific ward. */
  transferPatient(
    request: DeepPartial<TransferPatientRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Empty>;
  /** Removes a patient from the emergency ward. */
  removePatient(
    request: DeepPartial<RemovePatientRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Empty>;
  /** Notifies a patient that is called for a visit */
  callPatientForVisit(
    request: DeepPartial<CallPatientRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Empty>;
}

export type EmergencyWardPanelsServiceDefinition =
  typeof EmergencyWardPanelsServiceDefinition;
export const EmergencyWardPanelsServiceDefinition = {
  name: "EmergencyWardPanelsService",
  fullName: "com.git_commit_therapy.proto.emergency.EmergencyWardPanelsService",
  methods: {
    /** Retrieve the status of the "needToBeVisited" queue. */
    retrieveNeedToBeVisitedStatus: {
      name: "RetrieveNeedToBeVisitedStatus",
      requestType: Empty,
      requestStream: false,
      responseType: QueueStatusResponse,
      responseStream: false,
      options: {},
    },
    /** Retrieve the status of the "inVisiting" queue. */
    retrieveInVisitingStatus: {
      name: "RetrieveInVisitingStatus",
      requestType: Empty,
      requestStream: false,
      responseType: QueueStatusResponse,
      responseStream: false,
      options: {},
    },
    /** Retrieve a list of the last patients called. */
    retrieveLastPatientsCalled: {
      name: "RetrieveLastPatientsCalled",
      requestType: Empty,
      requestStream: false,
      responseType: LastPatientsCalledResponse,
      responseStream: false,
      options: {},
    },
  },
} as const;

export interface EmergencyWardPanelsServiceImplementation<CallContextExt = {}> {
  /** Retrieve the status of the "needToBeVisited" queue. */
  retrieveNeedToBeVisitedStatus(
    request: Empty,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<QueueStatusResponse>>;
  /** Retrieve the status of the "inVisiting" queue. */
  retrieveInVisitingStatus(
    request: Empty,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<QueueStatusResponse>>;
  /** Retrieve a list of the last patients called. */
  retrieveLastPatientsCalled(
    request: Empty,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<LastPatientsCalledResponse>>;
}

export interface EmergencyWardPanelsServiceClient<CallOptionsExt = {}> {
  /** Retrieve the status of the "needToBeVisited" queue. */
  retrieveNeedToBeVisitedStatus(
    request: DeepPartial<Empty>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<QueueStatusResponse>;
  /** Retrieve the status of the "inVisiting" queue. */
  retrieveInVisitingStatus(
    request: DeepPartial<Empty>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<QueueStatusResponse>;
  /** Retrieve a list of the last patients called. */
  retrieveLastPatientsCalled(
    request: DeepPartial<Empty>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<LastPatientsCalledResponse>;
}

type Builtin =
  | Date
  | Function
  | Uint8Array
  | string
  | number
  | boolean
  | undefined;

export type DeepPartial<T> = T extends Builtin
  ? T
  : T extends globalThis.Array<infer U>
    ? globalThis.Array<DeepPartial<U>>
    : T extends ReadonlyArray<infer U>
      ? ReadonlyArray<DeepPartial<U>>
      : T extends {}
        ? { [K in keyof T]?: DeepPartial<T[K]> }
        : Partial<T>;

function toTimestamp(date: Date): Timestamp {
  const seconds = Math.trunc(date.getTime() / 1_000);
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
