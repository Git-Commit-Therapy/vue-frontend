// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.6.1
//   protoc               v3.19.1
// source: patient_services.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { type CallContext, type CallOptions } from "nice-grpc-common";
import { Appointment } from "./appointment";
import { Empty } from "./google/protobuf/empty";
import { Timestamp } from "./google/protobuf/timestamp";
import { MedicalEvent } from "./medical_event";
import { MedicalExam } from "./medical_exam";
import { MedicalInfo } from "./medical_info";
import { Patient } from "./user";

export const protobufPackage = "com.git_commit_therapy.proto.patient";

export interface GetAppointmentsRequest {
  fromDate: Date | undefined;
  toDate: Date | undefined;
}

export interface GetAppointmentsResponse {
  appointments: Appointment[];
}

export interface GetMedicalInfoResponse {
  medicalInfo: MedicalInfo[];
}

export interface GetAllMedicalEventRequest {
  fromDate: Date | undefined;
  toDate: Date | undefined;
}

export interface GetAllMedicalEventResponse {
  medicalEvents: MedicalEvent[];
}

export interface GetAllMedicalExamRequest {
  fromDate: Date | undefined;
  toDate: Date | undefined;
}

export interface GetAllMedicalExamResponse {
  medicalExams: MedicalExam[];
}

export interface GetMedicalExamDetailsResponse {
  exam: MedicalExam | undefined;
}

function createBaseGetAppointmentsRequest(): GetAppointmentsRequest {
  return { fromDate: undefined, toDate: undefined };
}

export const GetAppointmentsRequest: MessageFns<GetAppointmentsRequest> = {
  encode(
    message: GetAppointmentsRequest,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.fromDate !== undefined) {
      Timestamp.encode(
        toTimestamp(message.fromDate),
        writer.uint32(10).fork(),
      ).join();
    }
    if (message.toDate !== undefined) {
      Timestamp.encode(
        toTimestamp(message.toDate),
        writer.uint32(18).fork(),
      ).join();
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): GetAppointmentsRequest {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetAppointmentsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.fromDate = fromTimestamp(
            Timestamp.decode(reader, reader.uint32()),
          );
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.toDate = fromTimestamp(
            Timestamp.decode(reader, reader.uint32()),
          );
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<GetAppointmentsRequest>): GetAppointmentsRequest {
    return GetAppointmentsRequest.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<GetAppointmentsRequest>,
  ): GetAppointmentsRequest {
    const message = createBaseGetAppointmentsRequest();
    message.fromDate = object.fromDate ?? undefined;
    message.toDate = object.toDate ?? undefined;
    return message;
  },
};

function createBaseGetAppointmentsResponse(): GetAppointmentsResponse {
  return { appointments: [] };
}

export const GetAppointmentsResponse: MessageFns<GetAppointmentsResponse> = {
  encode(
    message: GetAppointmentsResponse,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    for (const v of message.appointments) {
      Appointment.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): GetAppointmentsResponse {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetAppointmentsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.appointments.push(
            Appointment.decode(reader, reader.uint32()),
          );
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<GetAppointmentsResponse>): GetAppointmentsResponse {
    return GetAppointmentsResponse.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<GetAppointmentsResponse>,
  ): GetAppointmentsResponse {
    const message = createBaseGetAppointmentsResponse();
    message.appointments =
      object.appointments?.map((e) => Appointment.fromPartial(e)) || [];
    return message;
  },
};

function createBaseGetMedicalInfoResponse(): GetMedicalInfoResponse {
  return { medicalInfo: [] };
}

export const GetMedicalInfoResponse: MessageFns<GetMedicalInfoResponse> = {
  encode(
    message: GetMedicalInfoResponse,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    for (const v of message.medicalInfo) {
      MedicalInfo.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): GetMedicalInfoResponse {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetMedicalInfoResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.medicalInfo.push(MedicalInfo.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<GetMedicalInfoResponse>): GetMedicalInfoResponse {
    return GetMedicalInfoResponse.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<GetMedicalInfoResponse>,
  ): GetMedicalInfoResponse {
    const message = createBaseGetMedicalInfoResponse();
    message.medicalInfo =
      object.medicalInfo?.map((e) => MedicalInfo.fromPartial(e)) || [];
    return message;
  },
};

function createBaseGetAllMedicalEventRequest(): GetAllMedicalEventRequest {
  return { fromDate: undefined, toDate: undefined };
}

export const GetAllMedicalEventRequest: MessageFns<GetAllMedicalEventRequest> =
  {
    encode(
      message: GetAllMedicalEventRequest,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      if (message.fromDate !== undefined) {
        Timestamp.encode(
          toTimestamp(message.fromDate),
          writer.uint32(10).fork(),
        ).join();
      }
      if (message.toDate !== undefined) {
        Timestamp.encode(
          toTimestamp(message.toDate),
          writer.uint32(18).fork(),
        ).join();
      }
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number,
    ): GetAllMedicalEventRequest {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseGetAllMedicalEventRequest();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1: {
            if (tag !== 10) {
              break;
            }

            message.fromDate = fromTimestamp(
              Timestamp.decode(reader, reader.uint32()),
            );
            continue;
          }
          case 2: {
            if (tag !== 18) {
              break;
            }

            message.toDate = fromTimestamp(
              Timestamp.decode(reader, reader.uint32()),
            );
            continue;
          }
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    create(
      base?: DeepPartial<GetAllMedicalEventRequest>,
    ): GetAllMedicalEventRequest {
      return GetAllMedicalEventRequest.fromPartial(base ?? {});
    },
    fromPartial(
      object: DeepPartial<GetAllMedicalEventRequest>,
    ): GetAllMedicalEventRequest {
      const message = createBaseGetAllMedicalEventRequest();
      message.fromDate = object.fromDate ?? undefined;
      message.toDate = object.toDate ?? undefined;
      return message;
    },
  };

function createBaseGetAllMedicalEventResponse(): GetAllMedicalEventResponse {
  return { medicalEvents: [] };
}

export const GetAllMedicalEventResponse: MessageFns<GetAllMedicalEventResponse> =
  {
    encode(
      message: GetAllMedicalEventResponse,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      for (const v of message.medicalEvents) {
        MedicalEvent.encode(v!, writer.uint32(10).fork()).join();
      }
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number,
    ): GetAllMedicalEventResponse {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseGetAllMedicalEventResponse();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1: {
            if (tag !== 10) {
              break;
            }

            message.medicalEvents.push(
              MedicalEvent.decode(reader, reader.uint32()),
            );
            continue;
          }
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    create(
      base?: DeepPartial<GetAllMedicalEventResponse>,
    ): GetAllMedicalEventResponse {
      return GetAllMedicalEventResponse.fromPartial(base ?? {});
    },
    fromPartial(
      object: DeepPartial<GetAllMedicalEventResponse>,
    ): GetAllMedicalEventResponse {
      const message = createBaseGetAllMedicalEventResponse();
      message.medicalEvents =
        object.medicalEvents?.map((e) => MedicalEvent.fromPartial(e)) || [];
      return message;
    },
  };

function createBaseGetAllMedicalExamRequest(): GetAllMedicalExamRequest {
  return { fromDate: undefined, toDate: undefined };
}

export const GetAllMedicalExamRequest: MessageFns<GetAllMedicalExamRequest> = {
  encode(
    message: GetAllMedicalExamRequest,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.fromDate !== undefined) {
      Timestamp.encode(
        toTimestamp(message.fromDate),
        writer.uint32(10).fork(),
      ).join();
    }
    if (message.toDate !== undefined) {
      Timestamp.encode(
        toTimestamp(message.toDate),
        writer.uint32(18).fork(),
      ).join();
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): GetAllMedicalExamRequest {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetAllMedicalExamRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.fromDate = fromTimestamp(
            Timestamp.decode(reader, reader.uint32()),
          );
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.toDate = fromTimestamp(
            Timestamp.decode(reader, reader.uint32()),
          );
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(
    base?: DeepPartial<GetAllMedicalExamRequest>,
  ): GetAllMedicalExamRequest {
    return GetAllMedicalExamRequest.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<GetAllMedicalExamRequest>,
  ): GetAllMedicalExamRequest {
    const message = createBaseGetAllMedicalExamRequest();
    message.fromDate = object.fromDate ?? undefined;
    message.toDate = object.toDate ?? undefined;
    return message;
  },
};

function createBaseGetAllMedicalExamResponse(): GetAllMedicalExamResponse {
  return { medicalExams: [] };
}

export const GetAllMedicalExamResponse: MessageFns<GetAllMedicalExamResponse> =
  {
    encode(
      message: GetAllMedicalExamResponse,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      for (const v of message.medicalExams) {
        MedicalExam.encode(v!, writer.uint32(10).fork()).join();
      }
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number,
    ): GetAllMedicalExamResponse {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseGetAllMedicalExamResponse();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1: {
            if (tag !== 10) {
              break;
            }

            message.medicalExams.push(
              MedicalExam.decode(reader, reader.uint32()),
            );
            continue;
          }
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    create(
      base?: DeepPartial<GetAllMedicalExamResponse>,
    ): GetAllMedicalExamResponse {
      return GetAllMedicalExamResponse.fromPartial(base ?? {});
    },
    fromPartial(
      object: DeepPartial<GetAllMedicalExamResponse>,
    ): GetAllMedicalExamResponse {
      const message = createBaseGetAllMedicalExamResponse();
      message.medicalExams =
        object.medicalExams?.map((e) => MedicalExam.fromPartial(e)) || [];
      return message;
    },
  };

function createBaseGetMedicalExamDetailsResponse(): GetMedicalExamDetailsResponse {
  return { exam: undefined };
}

export const GetMedicalExamDetailsResponse: MessageFns<GetMedicalExamDetailsResponse> =
  {
    encode(
      message: GetMedicalExamDetailsResponse,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      if (message.exam !== undefined) {
        MedicalExam.encode(message.exam, writer.uint32(10).fork()).join();
      }
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number,
    ): GetMedicalExamDetailsResponse {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseGetMedicalExamDetailsResponse();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1: {
            if (tag !== 10) {
              break;
            }

            message.exam = MedicalExam.decode(reader, reader.uint32());
            continue;
          }
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    create(
      base?: DeepPartial<GetMedicalExamDetailsResponse>,
    ): GetMedicalExamDetailsResponse {
      return GetMedicalExamDetailsResponse.fromPartial(base ?? {});
    },
    fromPartial(
      object: DeepPartial<GetMedicalExamDetailsResponse>,
    ): GetMedicalExamDetailsResponse {
      const message = createBaseGetMedicalExamDetailsResponse();
      message.exam =
        object.exam !== undefined && object.exam !== null
          ? MedicalExam.fromPartial(object.exam)
          : undefined;
      return message;
    },
  };

export type PatientServicesDefinition = typeof PatientServicesDefinition;
export const PatientServicesDefinition = {
  name: "PatientServices",
  fullName: "com.git_commit_therapy.proto.patient.PatientServices",
  methods: {
    /** Get Patient data */
    getPatient: {
      name: "GetPatient",
      requestType: Empty,
      requestStream: false,
      responseType: Patient,
      responseStream: false,
      options: {},
    },
    /** Get a list of appointments */
    getAppointments: {
      name: "GetAppointments",
      requestType: GetAppointmentsRequest,
      requestStream: false,
      responseType: GetAppointmentsResponse,
      responseStream: false,
      options: {},
    },
    /** Get all medical information */
    getAllMedicalInfo: {
      name: "GetAllMedicalInfo",
      requestType: Empty,
      requestStream: false,
      responseType: GetMedicalInfoResponse,
      responseStream: false,
      options: {},
    },
    /** Retrieve all medical events */
    getAllMedicalEvent: {
      name: "GetAllMedicalEvent",
      requestType: GetAllMedicalEventRequest,
      requestStream: false,
      responseType: GetAllMedicalEventResponse,
      responseStream: false,
      options: {},
    },
    /** Retrieve the list of all medical exams without the medical report */
    getAllMedicalExam: {
      name: "GetAllMedicalExam",
      requestType: GetAllMedicalExamRequest,
      requestStream: false,
      responseType: GetAllMedicalExamResponse,
      responseStream: false,
      options: {},
    },
    /** Get details for a specific medical exam */
    getMedicalExamDetails: {
      name: "GetMedicalExamDetails",
      requestType: MedicalExam,
      requestStream: false,
      responseType: GetMedicalExamDetailsResponse,
      responseStream: false,
      options: {},
    },
  },
} as const;

export interface PatientServicesServiceImplementation<CallContextExt = {}> {
  /** Get Patient data */
  getPatient(
    request: Empty,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Patient>>;
  /** Get a list of appointments */
  getAppointments(
    request: GetAppointmentsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<GetAppointmentsResponse>>;
  /** Get all medical information */
  getAllMedicalInfo(
    request: Empty,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<GetMedicalInfoResponse>>;
  /** Retrieve all medical events */
  getAllMedicalEvent(
    request: GetAllMedicalEventRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<GetAllMedicalEventResponse>>;
  /** Retrieve the list of all medical exams without the medical report */
  getAllMedicalExam(
    request: GetAllMedicalExamRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<GetAllMedicalExamResponse>>;
  /** Get details for a specific medical exam */
  getMedicalExamDetails(
    request: MedicalExam,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<GetMedicalExamDetailsResponse>>;
}

export interface PatientServicesClient<CallOptionsExt = {}> {
  /** Get Patient data */
  getPatient(
    request: DeepPartial<Empty>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Patient>;
  /** Get a list of appointments */
  getAppointments(
    request: DeepPartial<GetAppointmentsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<GetAppointmentsResponse>;
  /** Get all medical information */
  getAllMedicalInfo(
    request: DeepPartial<Empty>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<GetMedicalInfoResponse>;
  /** Retrieve all medical events */
  getAllMedicalEvent(
    request: DeepPartial<GetAllMedicalEventRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<GetAllMedicalEventResponse>;
  /** Retrieve the list of all medical exams without the medical report */
  getAllMedicalExam(
    request: DeepPartial<GetAllMedicalExamRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<GetAllMedicalExamResponse>;
  /** Get details for a specific medical exam */
  getMedicalExamDetails(
    request: DeepPartial<MedicalExam>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<GetMedicalExamDetailsResponse>;
}

type Builtin =
  | Date
  | Function
  | Uint8Array
  | string
  | number
  | boolean
  | undefined;

export type DeepPartial<T> = T extends Builtin
  ? T
  : T extends globalThis.Array<infer U>
    ? globalThis.Array<DeepPartial<U>>
    : T extends ReadonlyArray<infer U>
      ? ReadonlyArray<DeepPartial<U>>
      : T extends {}
        ? { [K in keyof T]?: DeepPartial<T[K]> }
        : Partial<T>;

function toTimestamp(date: Date): Timestamp {
  const seconds = Math.trunc(date.getTime() / 1_000);
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
